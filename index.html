<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/splide.min.css">
    <link rel="stylesheet" href="css/main.css">
    <title>Javascript!!!</title>
    <!-- <script defer src="https://s0.2mdn.net/ads/studio/cached_libs/gsap_3.11.5_min.js"></script> -->
    <script defer src="js/gsap.min.js"></script>
    <script defer src="js/ScrollTrigger.min.js"></script>
    <script defer src="js/splide.min.js"></script>
    <script defer src="js/index.js"></script>
    <script src="js/timer.js"></script>

</head>
<body>
    
    <header>
        <h1>Javascript For Frontend!</h1>
    </header>

    <p>Change header color to...</p>

    <button id="red-button">Red</button>
    <button onclick="makeHeaderGreen()" id="green-button">Green</button>
    <button id="blue-button">Blue</button>
    <button onclick="makeHeaderBlack()" id="black-button">Black</button>
    
    <main>

        <nav>
            <a href="#variables-section">Variables</a>
            <a href="#strings-section">Strings</a>
            <a href="#numbers-section">Numbers</a>
            <a href="#booleans-section">Booleans</a>
            <a href="#selectors-section">Query Selectors</a>
            <a href="#changing-properties-section">Changing Properties</a>
            <a href="#functions-section">Functions</a>
            <a href="#arrays-section">Arrays</a>
            <a href="#math-random-section">Random Array Item</a>
            <a href="#loops-section">Loops</a>
            <a href="#adding-dom-section">Adding New Content</a>
            <a href="#dates-and-interpolation-section">Dates & String Interpolation</a>
            <a href="#conditional-section">Conditionals</a>
            <a href="#objects-section">Javascript Objects</a>
            <a href="#intro-to-gsap-section">Intro to GSAP</a>
            <a href="#splide-section">Splide</a>
            <a href="#google-ads-section">Google Ads</a>
            <a href="#fouc-section">Fixing Flash Of Unstyled Content</a>
            <a href="#scrolltrigger-section">ScrollTrigger</a>
            <a href="#parallax-section">Parallax</a>
        </nav>
        
        <section id="variables-section">
            <h2>Declaring Variables</h2>
            <p>Variables can be declared using <strong>var, let, and const</strong>. These days only <strong>let and const</strong> are used. Using <strong>let</strong> allows you to reassign the variable later while using <strong>const</strong> means it is a <strong>constant</strong> and cannot be reassigned:</p>
            
            <div class="code-block">
                <code>
                    var oldVariable = "I am the old way of declaring variables";
                    <br>
                    let changeableVariable = "You can change me later!";
                    <br>
                    changeableVariable = "I have been changed now!"
                    <br>
                    const constantVariable = "I cannot be changed later..."
                </code>
            </div>
        </section>
        
        <section id="strings-section">
            <h2>Strings</h2>
            <p>A string is generally text or a string of characters. You create strings by wrapping them in matching quotes:</p>
            
            <div class="code-block">
                <code>
                    const myString = "I am a string";
                    <br>
                    const myOtherString = "I am another string";
                    <br>
                    const myFinalString = `I am a special string`;
                </code>
            </div>

            <p>Strings can be added together to form a new string, this operation is known as "concatenation":</p>
            <div class="code-block">
                <code>
                    const stringOne = "Hello";
                    <br>
                    const stringTwo = "World";
                    <br>
                    const myFinalString = stringOne + stringTwo;
                    <br>
                    // will be "HelloWorld"
                </code>
            </div>
        </section>

        <section id="numbers-section">
            <h2>Numbers</h2>
            <p>You can define and use numbers the way you generally expect:</p>

            <div class="code-block">
                <code>
                    const one = 1;
                    <br>
                    const two = 2;
                    <br>
                    const sum = one + two
                </code>
            </div>
        </section>

        <section id="booleans-section">
            <h2>Booleans</h2>
            <p>A boolean represents either a true or a false value which is useful in <strong>if/else</strong> statements:</p>

            <div class="code-block">
                <code>
                    const truthful = true;
                    <br>
                    const notTruthful = false;
                </code>
            </div>
        </section>

        <section id="selectors-section">
            <h2>Selectors</h2>
            <p>There are a number of different selectors such as <code>getElementById</code> and <code>getElementsByClassName</code> however the one I use most often is <code>querySelector</code> since it's very flexible and powerful:</p>

            <div class="code-block">
                <code>
                    const getAnElement = document.querySelector("h1");
                    <br>
                    const gottenById = document.querySelector("#variables-section")
                    <br>
                    const gottenByClass = document.querySelector(".code-block")
                </code>
            </div>

            <p>The <code>querySelector</code> will only get the first element it finds and if it finds nothing it'll give you back <code>undefined</code>...</p>
        </section>

        <section id="changing-properties-section">
            <h2>Changing Properties</h2>
            <p>Once you have an element you may change its attributes / properties:</p>

            <div class="code-block">
                <code>
                    const h1 = document.querySelector("h1");
                    <br>
                    h1.innerText = "Frontend Javascript";
                    <br>
                    h1.innerHTML = "Frontend &lt;i&gt;Javascript&lt;/i&gt;";
                    <br>
                    h1.style.color = "red";
                </code>
            </div>

            <p>The <code>querySelector</code> will only get the first element it finds and if it finds nothing it'll give you back <code>undefined</code>...</p>
        </section>

        <section id="functions-section">
            <h2>Functions</h2>
            <p>Functions are executable pieces of code that can allow us to perform a set of instructions on each activation. For example these two functions will change the text of the header each time they're clicked:</p>

            <div class="code-block">
                <code>
                    function makeHeaderRed() {
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;const header = document.querySelector('h1');
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;header.style.color = "red";
                        <br>
                    }
                    <br>
                    <br>
                    function makeHeaderBlue() {
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;const header = document.querySelector('h1');
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;header.style.color = "blue";
                        <br>
                    }
                </code>
            </div>

            <p>We can then attach them to buttons directly:</p>

            <div class="code-block">
                <code>
                    &lt;button onclick="makeHeaderRed()"&gt;Red&lt;/button&gt;
                    <br>
                    &lt;button onclick="makeHeaderBlue()"&gt;Blue&lt;/button&gt;
                </code>
            </div>

            <p>...or we can attach them via Javascript:</p>

            <div class="code-block">
                <code>
                    const redButton = document.querySelector("#red-button");
                    <br>
                    redButton.addEventListener("click", makeHeaderRed);
                </code>
            </div>

            <p>Functions can also take in or give back data using arguments and the "return" keyword:</p>

            <div class="code-block">
                <code>
                    function addTogether(numberOne, numberTwo) {
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;return numberOne + numberTwo;
                        <br>
                    }
                    <br>
                    <br>
                    addTogether(5,6)
                    <br>
                    // this will give back 11

                </code>
            </div>
        </section>

        <section id="arrays-section">
            <h2>Arrays</h2>

            <p>An array is a more complex data type which allows us to store several values in a sequence. Basically, an array is a collection of data:</p>

            <div class="code-block">
                <code>
                    const catNames = ["Octavia", "Ursula", "Olivia"]
                    <br>
                    catNames.length // this will return 3
                    <br>
                    const emptyArray = []
                    emptyArray.length // this will return 0
                    <br>
                    const arrayWithDifferentDataTypes = [42, "meaning of life", true]
                    <br>
                    arrayWithDifferentDataTypes.length // return 3
                </code>
            </div>

            <p>Each item in an array has an "index" which is basically what number in the array's order it is. Javascript is "zero indexed" which means it starts counting at "0" instead of at "1". We can access and change items in an array with its index:</p>

            <div class="code-block">
                <code>
                    const catNames = ["Octavia", "Ursula", "Olivia"]
                    <br>
                    catNames[2] // this will be "Olivia"
                    <br>
                    catNames[2] = "Elizabeth"
                </code>
            </div>

            <p>We can add items to the end of the array with <code>.push()</code> and remove them with <code>.pop()</code>. We can also add and remove items from the beginning with <code>.unshift()</code> and <code>.shift()</code>:</p>

            <div class="code-block">
                <code>
                    const catNames = ["Octavia", "Ursula", "Olivia"]
                    <br>
                    catNames.push("Guinevere")
                    <br>
                    // ["Octavia", "Ursula", "Olivia", "Guinevere"]
                    <br>
                    catNames.pop()
                    <br>
                    // ["Octavia", "Ursula", "Olivia"]
                    <br>
                    catNames.unshift("Garfield")
                    <br>
                    // ["Garfield", "Octavia", "Ursula", "Olivia"]
                    <br>
                    catNames.shift()
                    <br>
                    // ["Octavia", "Ursula", "Olivia"]
                </code>

                <p>These changes to the array are "destructive"; they don't make a new array, they instead edit the old array.</p>
            </div>

        </section>

        <section class="math-random-section">
            <h2>Random Array Item</h2>

            <p>If we want to get a random item from an array we need to use a special set of JS functions starting with <code>Math.random</code>. Using <code>Math.random</code> will return a random fraction between <code>0</code> and <code>1</code>. We then multiply that by the length of the array and then round down using <code>Math.floor</code>. All together this looks like this:</p>
            
            <div class="code-block">
                function randomArrayItem(array) {
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;
                const index = Math.floor(Math.random() * array.length)
                <br>
                &nbsp;&nbsp;&nbsp;&nbsp;
                return array[index]
                <br>
                }
            </div>

            <p>Random cat name: <span style="font-weight: bold;" id="cat-name-display">???</span></p>
            <button onclick="displayRandomCatName()">Get Random Cat Name</button>
        </section>

        <section id="loops-section">
            <h2>Loops</h2>
            <p>Doing something for each item in an array is known as "looping" and Javascript has a lot of different ways of achieving loops. There is the quite complicated for loop with an index that you'll see commonly:</p>

            <div class="code-block">
                <code>
                    for (let index = 0; index < array.length; index++) {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        doSomething( array[i] )
                        <br>
                    }
                </code>
            </div>

            <p>This will start at the beginning of the array and run a function on each item until the end of the array.</p>

            <p>There is also a far simpler version of the loop that doesn't use the index:</p>

            <div class="code-block">
                <code>
                    for (item in array) {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        doSomething( item )
                        <br>
                    }
                </code>
            </div>

            <p>This has the drawback that we don't get the index but if we don't care about it this loop is easier to write.</p>

        </section>

        <section id="adding-dom-content-section">

            <h2>Adding New Content</h2>

            <p>You can add new items to the DOM (Document Object Model) using three steps...</p>

            <ol>
                <li>Create the element so it exists.</li>
                <li>Give the element attributes, text, and anything else it needs.</li>
                <li>Add the element to where it needs to go.</li>
            </ol>

            <p>To create an element we use the special <code>.createElement()</code> function letting it know what kind of element we'd like to create:</p>
            
            <div class="code-block">
                <code>
                    const pTag = document.createElement('p')
                </code>
            </div>

            <p>Then we can add things like <code>textContent</code> or a <code>className</code>:</p>

            <div class="code-block">
                <code>
                    pTag.textContent = "Lorem ipsum dolorum etc."
                    <br>
                    pTag.className = "lorem-ipsum"
                </code>
            </div>

            <p>Finally we can find a place to put it, usually in a specific container:</p>

            <div class="code-block">
                <code>
                    const loremContainer = document.querySelector("#lorem-container")
                    <br>
                    loremContainer.append(pTag)
                </code>
            </div>

            <p>It should now show up on the screen! The code below was created using this method and looping over the <code>catNames</code> array:</p>
            
            <div id="cat-names-area">
            </div>

        </section>

        <section id="dates-and-interpolation-section">
            <h2>Date & String Interpolation</h2>

            <p>You can access the current day and time with <code>new Date()</code> and use its various attributes to add it to a string through a process known as string interpolation:</p>

            <div class="code-block">
                <code>
                    const now = new Date()
                    
                    const hour = now.getHours()
                    const minute = now.getMinutes()

                    const formattedString = `It is currently ${hour}:${minute}...`
                </code>
            </div>

            <p>String interpolation can only happen with backtics, a.k.a. the <code style="color:white;background-color:#555;">`</code> key. You can interpolate values and variables in the <code>${ }</code> syntax.</p>
        </section>

        <section id="conditionals-section">
            <h2>Conditional Statements</h2>

            <p>In Javascript (and many other languages) you can use the language if "if this do this and else do this". This is known technically as conditional logic but follows a very simple idea... if something is true we do something and otherwise we do something else.</p>

            <div class="code-block">
                <code>
                    if (true) {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        console.log("I am true")
                        <br>
                    } else {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        console.log("I am false")
                        <br>
                    }
                </code>
            </div>

            <p>Certain values and expressions come out explicitly as <code>true</code> or <code>false</code> such as <code>1 &lt; 2</code> which will be <code>true</code> and <code>2 &lt; 1</code> which comes out to <code>false</code>.</p>

            <p>Additionally, every value in Javascript has an inherent "truthiness" to it. For example, in an <code>if</code> statement the <code>undefined</code> value will act just like the <code>false</code> boolean.</p>

            <p>You can test an item's "truthiness" by converting it to a boolean:</p>

            <div class="code-block">
                <code>
                    Boolean("Hello world") // true
                    <br>
                    Boolean("") // false
                    <br>
                    Boolean(100) // true
                    <br>
                    Boolean(0) // false
                    <br>
                    Boolean( ["hello", "world"] ) // true
                    <br>
                    Boolean( [] ) // true
                </code>
            </div>

            <p>One additional wrinkle to an <code>if else</code> statement is that you aren't limited to a single <code>if</code>:</p>

            <div class="code-block">
                <code>
                    if (1 > 2) {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        console.log("First condition was true")
                        <br>
                    } else if (2 > 3) {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        console.log("Second condition was true")
                        <br>
                    } else if (3 > 4) {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        console.log("Third condition was true")
                        <br>
                    } else {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        console.log("None of the conditions were true")
                        <br>
                    }
                </code>
            </div>

            <p>Finally, Javascript has a special syntax for these expressions where we can say "if this AND this are true" as well as "if this OR this are true". The <code>&&</code> is used to indicate both must be true and the <code>||</code> is used to indicate either one can be true:</p>

            <div class="code-block">
                <code>
                    true && true // true
                    <br>
                    true && false // false
                    <br>
                    true || false // true
                    <br>
                    false || false // false
                </code>
            </div>
        </section>

        <section id="objects-section">
            <h2>Javascript Objects</h2>

            <p>An object is a data structure similar to an array however unlike an array which uses an index to track the data inside it, an object uses a "key" which is sort of like a label:</p>

            <div class="code-block">
                <code>
                    const otter = { species: "Otter", habitat: "rivers" }
                </code>
            </div>

            <p>Accessing information inside an object can be done through either dot notation or bracket notation and additionally it's easy to set an object's values this way as well.</p>

            <div class="code-block">
                <code>
                    otter.species // "Otter"
                    <br>
                    otter["habitat"] // "rivers"
                    <br>
                    otter.species = "River Otter"
                    <br>
                    otter["habitat"] = "rivers and oceans"
                </code>
            </div>

            <p>Objects can even be nested inside other objects:</p>

            <div class="code-block">
                <code>
                    const animals = {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        octopus: { species: "Octopus", habitat: "oceans" }
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        deer: { species: "Deer", habitat: "forests" }
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        otter: { species: "Otter", habitat: "rivers" }
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        tiger: { species: "Tiger", habitat: "jungles" }
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        sloth: { species: "Sloth", habitat: "jungles" }
                        <br>
                    }
                </code>
            </div>

            <p>Below we've used a similar nested object to create a tab for each of the animals and clicking the tag uses DOM manipulation to show more data from the inner objects (check index.js to see how it's done):</p>

            <ul id="tabs-area">
            </ul>

            <div id="information-area">

                <h3 id="pet-species">Species Goes Here</h3>
                <p id="age">Age goes here</p>
                <p id="size">Size goes here</p>
                <p id="habitat">Habitat goes here</p>

            </div>

        </section>

        <section id="intro-to-gsap-section">
            <h2>Intro to GSAP</h2>

            <p>You can find more information about GSAP <a href="https://gsap.com/">here</a> including their <a href="https://gsap.com/resources/get-started">tutorial</a>. Reading documentation and going through a tutorial is often the best way to learn a new library.</p>

            <p>Animating the box below uses a tween. This tween can be thought of as a part of an entire sequence of animation however in our case the animation only uses one tween to get the desired effect:</p>

            <div class="code-block">
                <code>
                    const tween = gsap.("#box-one", {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        x: "-300px",
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        backgroundColor: "#000",
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        rotation: -180,
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        duration: 3,
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        repeat: -1,
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        yoyo: true,
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        ease: "power1.in"
                        <br>
                    })
                </code>
            </div>

            <p>Tweens require the identity of the element they're animating as well as an object with keys and values for the different attributes of the animation.</p>

            <p>Ease is a particularly important attribute since it determines the animation curve - essentially how fast the animation progresses at different points.</p>

            <p>A tween that uses <code>.from()</code> means it starts at a specific animation state (for example left by 300 pixels) and goes to it's natural place on the screen. A tween that uses <code>.to()</code> will instead begin at it's natural place on the screen and move to the specified animation state (for example left by 300 pixels).</p>

            <p>If we want to use more than one tween on an element they will all trigger simultaneously. Sometimes we want tweens to happen in sequence and we can either <code>delay</code> a tween or else use a special construct known as a <code>timeline</code>:</p>

            <div class="code-block">
                <code>
                    const boxTwoTimeline = gsap.timeline({ defaults: { duration: 2 } })
                    <br><br>
                    boxTwoTimeline.to("#box-two", {borderRadius: "50px",})
                    <br>
                    .to("#box-two", {y: -300,ease: "bounce.in"})
                    <br>
                    .to("#box-two", {opacity: 0,})
                </code>
            </div>

            <p>In a timeline all the chained <code>.to</code> tweens will wait until the previous tween completes. Additionally the defaults in the timeline will get applied to each tween meaning each tween lasts 2 seconds in this case.</p>

            <p>A timeline is useful for multiple different tweens that can be on the same element or different elements but tweens can also affect multiple elements which have all be selected at the same time. For example if you would like to affect all <code>&lt;svg&gt;</code> elements:</p>

            <div class="code-block">
                <code>
                    gsap.to("svg", { rotation: 360 })
                </code>
            </div>

            <p>This will target every <code>&lt;svg&gt;</code> and make it rotate. Additionally if you want to stagger the animations and make each element wait one second after the previous element animates:</p>

            <div class="code-block">
                <code>
                    gsap.to("svg", { rotation: 360, stagger: 1 })
                </code>
            </div>

            <p>Although you can add a duration here, these are considered a single tween all together and the animation is considered to be at its end when the last element finishes its animation which might be much longer than you expect with a stagger.</p>

            <div id="gsap-sandbox">

                <button onclick="pauseAll()">Pause</button>

                <button onclick="playAll()">Play</button>
                
                <div id="box-one"></div>

                <p id="animated-words">Hello world</p>

                <div id="box-two">
                    <a href="#">Word</a>
                </div>

                <svg version="1.1" id="svg" width="260" height="200" viewBox="0 0 260 200" xml:space="preserve">
                    <rect id="svgRectangle" x="20" y="60" width="220" height="80" fill="#f00"></rect>
                </svg>

                <svg version="1.1" id="svg" width="260" height="200" viewBox="0 0 260 200" xml:space="preserve">
                    <rect id="svgRectangle" x="20" y="60" width="220" height="80" fill="#f00"></rect>
                </svg>


                <svg version="1.1" id="svg" width="260" height="200" viewBox="0 0 260 200" xml:space="preserve">
                    <rect id="svgRectangle" x="20" y="60" width="220" height="80" fill="#f00"></rect>
                </svg>


                <svg version="1.1" id="svg" width="260" height="200" viewBox="0 0 260 200" xml:space="preserve">
                    <rect id="svgRectangle" x="20" y="60" width="220" height="80" fill="#f00"></rect>
                </svg>


                <svg version="1.1" id="svg" width="260" height="200" viewBox="0 0 260 200" xml:space="preserve">
                    <rect id="svgRectangle" x="20" y="60" width="220" height="80" fill="#f00"></rect>
                </svg>


                <svg version="1.1" id="svg" width="260" height="200" viewBox="0 0 260 200" xml:space="preserve">
                    <rect id="svgRectangle" x="20" y="60" width="220" height="80" fill="#f00"></rect>
                </svg>

            </div>

        </section>
        
        <section id="splide-section" class="splide" aria-label="Splide Example">
        <div class="splide__track">
                <ul class="splide__list">
                    <li class="splide__slide">
                        <div style="background: blue;height:300px;width:100%;">Slide 01</div>
                    </li>
                    <li class="splide__slide">
                        <div style="background: blue;height:300px;width:100%;">Slide 01</div>
                    </li><li class="splide__slide">
                        <img src="assets/planet-earth.png" style="height:300px;">
                    </li>
                </ul>
        </div>
        </section>

        <section id="google-ads-section">
            <h2>Google Banner Ads with GSAP</h2>

            <a href="https://www.earth.com">
                <div id="banner-ad-area">
                    <img src="assets/planet-earth.png" alt="planet earth">
                    <div id="final-panel">
                        <p>Apply Today To Learn If Earth Is Right For You</p>
                    </div>
                </div>
            </a>
            
            <p>Google ads have a series of limitations: you must choose from a select size (height and width) for the ad which are a few too many to list here. Ads generally use jpg, png, or gif for images. Most importantly, the overall file size for the ad needs to be 150kb or less.</p>

            <p>The file size restriction is probably the toughest if you want to add animations but luckily for us the GSAP CDN has been whitelisted so it doesn't count!</p>

            <p>One last mention, animations need to be 30 seconds or less. An animation can loop but the loop must stop at the 30 second mark.</p>
                
            <p>Also a gif must be less than 5 frames per second but we don't have to worry about that since we won't be using them here.</p>

        </section>

        <section id="fouc-section">
            <h2>Fixing Flash Of Unstyled Content</h2>

            <p>Sometimes an ad or animation hasn't had time to "set up" before the page is fully loaded and this might mean a user sees the unanimated starting position of the ad. This can be ugly so we avoid this by initially starting the container with <code>visibility: hidden</code> and then make it visible with <code>.set("#conatiner", {visibility: "visible"})</code> to make it viewable.</p>

            <p>For some added insurance you also might trigger the animation inside a function using a special event:</p>

            <div class="code-block">
                <code>
                    window.addEventListener("load", animationFunction)
                </code>
            </div>

            <p>This will wait until all assets, scripts, styles, and elements have been loaded and rendered before it properly runs the animation.</p>
        </section>

        <section id="scrolltrigger-section">
            <h2>GSAP Scrolltrigger</h2>

            <div class="scroll-box" id="scroll-one"></div>

            <div class="scroll-box" id="scroll-two"></div>

            <div class="scroll-box" id="scroll-three"></div>

            <div class="scroll-box" id="scroll-four"></div>

            <div class="scroll-box" id="scroll-five"></div>

            <div class="scroll-box" id="scroll-six"></div>

            <p>ScrollTrigger is a special GSAP plugin (an expansion to the library) which gives access to some special attributes in an animation. When used, this can help us to only trigger animations when a user has actually scrolled to that animation's position.</p>

            <p>In order to use this plugin it must first be registered:</p>

            <div class="code-block">
                <code>
                    gsap.registerPlugin(ScrollTrigger)
                </code>
            </div>

            <p>A scroll trigger can simply trigger on an element by stating which element will trigger it:</p>

            <div class="code-block">
                <code>
                    gsap.registerPlugin(ScrollTrigger)
                </code>
            </div>

            <p>Once registered the animation needs to know which element "triggers" it. This is usually the same as the element that the animation is on:</p>

            <div class="code-block">
                <code>
                    gsap.from('#scroll-one', {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        x: "-200px",
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        duration: 5,
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        scrollTrigger: '#scroll-one'
                        <br>
                    }
                </code>
            </div>

            <p>We can make this more robust by making the scrolltrigger property an object with some additional properties of its own:</p>

            <div class="code-block">
                <code>
                    gsap.from("#scroll-one", {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        x: "-200px",
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        duration: 5,
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        scrollTrigger: {
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                            trigger: "#scroll-one",
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                            start: "top 60%",
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                            end: "bottom 40%",
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                            toggleActions: "play pause resume none"
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        },
                        <br>
                    })
                </code>
            </div>

            <p>The <code>start</code> and <code>end</code> properties determine where relative to the viewport and the element the animation triggers, in this case it will start when the top of the element hits 60% of the way down the page. The <code>end</code> has to do with the <code>toggleActions</code>.</p>

            <p>The <code>toggleActions</code> is a string of four actions that happen at different times. The first is simply what happens when the animation is triggered by the start of the scroll hitting the start of the element. The second triggers when the end of the scroll passes the end of the element (in this case we pause the animation). The third is what happens when we scroll back up so the end of the viewport is once again within the element's bounds. The fourth is what happens if someone scrolls up past the element and then scroll back down (this can include restarting the animation or simply leaving it as is).</p>

            <p>There is one additional and very helpful property called <code>scrub</code> which causes an animation to step a percentage of the way through based on how far we've scrolled through it:</p>

            <div class="code-block">
                <code>
                    gsap.from("#scroll-one", {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        x: "-200px",
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        scrollTrigger: {
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                            trigger: "#scroll-one",
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                            start: "top 60%",
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                            end: "bottom 40%",
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                            scrub: true
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        },
                        <br>
                    })
                </code>
            </div>

            <p>With <code>scrub</code> the animation has no <code>duration</code> and doesn't need a <code>start</code> or <code>end</code> since the animation's progress is completely tied to how far down you've scrolled.</p>

            <p>In general, a scrollTrigger can only be applied to one element at a time which means to apply multiple scrollTriggers at the same time you must use something like a <code>for</code> loop.</p>

        </section>

        <section id="parallax-section">
            <h2>Parallax with GSAP</h2>

            <div id="parallax-sandbox">

                <img src="assets/planet-fire.png" 
                alt="fire planet" 
                style="left:30%;width:5%;top:20%"
                data-speed="0.05">

                <img src="assets/planet-mars.png" 
                alt="planet mars" 
                style="left:60%;width:5%;top:60%"
                data-speed="0.05">

                <img src="assets/planet-desert.png" 
                alt="desert planet" 
                style="left:10%;width:10%;top:30%"
                data-speed="0.20">
                
                <img src="assets/planet-molten.png" 
                alt="molten planet" 
                style="left:40%;width:10%;top:30%"
                data-speed="0.20">
                
                <img src="assets/planet-snowy.png" 
                alt="snowy planet" 
                style="left:-10%;width:20%;top:50%"
                data-speed="0.40">
                
                <img src="assets/planet-green.png" 
                alt="green planet" 
                style="left:15%;width:30%;top:60%"
                data-speed="0.60">
                
                <img src="assets/planet-earth.png" 
                alt="planet earth" 
                style="left:60%;width:50%;top:80%"
                data-speed="1">

                <span>space</span>

            </div>

            <p>Parallax takes advantage of how human vision works to create the illusion of depth. When moving past a series of objects, those objects that are far away seem to move slower across our vision than the objects that are closer. By making things "closer" to the viewer move fast as we scroll past them and objects "farther" from the viewer scroll slowly we create this parallax illusion.</p>

            <p>In terms of animating them with GSAP we've created a container with absolute objects, the closer ones in this case are larger. Each object has a dataset known as <code>data-speed</code> which determines who fast it moves. Larger numbers mean those objects move more quickly and feel like they're in the foreground:</p>

            <div class="code-block">
                <code>
                &lt;img src="assets/planet-green.png"
                <br>
                alt="green planet" 
                <br>
                style="left:15%;width:30%;top:60%"
                <br>
                data-speed="0.60"&gt;
                </code>
            </div>

            <p>From there we create a scrub timeline and attach a tween to each image and the timeline. This tween will move the image further depending on the animation's <code>data-speed</code>:</p>

            <div class="code-block">
                <code>
                    const parallaxTimeline = gsap.timeline({
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        scrollTrigger: {
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;
                            &nbsp;&nbsp;&nbsp;&nbsp;
                            trigger: "#parallax-sandbox",
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;
                            &nbsp;&nbsp;&nbsp;&nbsp;
                            scrub: true,
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;
                            &nbsp;&nbsp;&nbsp;&nbsp;
                            invalidateOnRefresh: true
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        }
                        <br>
                    })
                    <br>
                    <br>
                    document.querySelectorAll("#parallax-sandbox img").forEach(function(img) {
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        const speed = img.dataset.speed
                        <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        parallaxTimeline.to(img, {
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                            y: -(img.offsetHeight * speed),
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                            ease: "none"
                            <br>&nbsp;&nbsp;&nbsp;&nbsp;
                        }, 0)
                        <br>
                    })
                </code>
            </div>

        </section>


    </main>

</body>
</html>